<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paper Map</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    /* Theme variables */
    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --border-color: #30363d;
      --text-primary: #f0f6fc;
      --text-secondary: #c9d1d9;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --plot-bg: #0d1117;
      --plot-grid: #21262d;
      --plot-zero: #30363d;
    }

    [data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f6f8fa;
      --bg-tertiary: #eaeef2;
      --border-color: #d0d7de;
      --text-primary: #1f2328;
      --text-secondary: #424a53;
      --text-muted: #656d76;
      --accent: #0969da;
      --plot-bg: #ffffff;
      --plot-grid: #eaeef2;
      --plot-zero: #d0d7de;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-secondary);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    header h1 {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .stats {
      font-size: 13px;
      color: var(--text-muted);
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
      margin-left: auto;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .control-group label {
      font-size: 12px;
      color: var(--text-muted);
    }
    input[type="number"], select, input[type="text"] {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      width: 70px;
    }
    select { width: auto; }
    input[type="checkbox"] {
      accent-color: var(--accent);
    }
    button {
      background: #238636;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }
    button:hover { background: #2ea043; }

    /* Theme toggle */
    .theme-toggle {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .theme-toggle:hover {
      background: var(--border-color);
    }

    /* Main content */
    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Plot */
    #plot {
      flex: 1;
      min-width: 0;
    }

    /* Detail panel */
    .detail-panel {
      width: 0;
      min-width: 0;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-color);
      overflow-y: auto;
      overflow-x: hidden;
      padding: 0;
      position: relative;
    }
    .detail-panel.active {
      width: 350px;
      min-width: 250px;
      max-width: 600px;
      padding: 16px;
      padding-left: 20px;
    }
    .resize-handle {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      cursor: ew-resize;
      background: transparent;
      transition: background 0.15s;
    }
    .resize-handle:hover,
    .resize-handle.dragging {
      background: var(--accent);
    }
    .detail-panel h2 {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 12px;
      line-height: 1.4;
    }
    .detail-panel .meta {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .detail-panel .meta span {
      display: inline-block;
      margin-right: 12px;
    }
    .detail-panel .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    .badge.paper { background: #388bfd33; color: #58a6ff; }
    .badge.app { background: #a371f733; color: #bc8cff; }
    .badge.cluster {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }
    .detail-panel .abstract {
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-muted);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
    }
    .detail-panel .links {
      margin-top: 12px;
    }
    .detail-panel .links a {
      color: var(--accent);
      font-size: 12px;
      text-decoration: none;
      margin-right: 12px;
    }
    .detail-panel .links a:hover { text-decoration: underline; }
    .detail-panel .notes {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
    }
    .detail-panel .notes h3 {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .detail-panel .notes-content {
      font-size: 12px;
      line-height: 1.6;
      color: var(--text-secondary);
      background: var(--bg-tertiary);
      padding: 10px;
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
    }
    .detail-panel .similar-papers {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
    }
    .detail-panel .similar-papers h3 {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .detail-panel .similar-papers ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .detail-panel .similar-papers li {
      font-size: 12px;
      padding: 6px 0;
      border-bottom: 1px solid var(--bg-tertiary);
      cursor: pointer;
      color: var(--text-secondary);
    }
    .detail-panel .similar-papers li:hover {
      color: var(--accent);
    }
    .detail-panel .similar-papers .year {
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .legend-diamond {
      width: 10px;
      height: 10px;
      background: #bc8cff;
      transform: rotate(45deg);
    }

    /* Cluster Panel */
    .cluster-panel {
      width: 200px;
      min-width: 200px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      overflow-y: auto;
      padding: 12px;
      transition: width 0.2s, min-width 0.2s, padding 0.2s;
    }
    .cluster-panel.collapsed {
      width: 48px;
      min-width: 48px;
      padding: 8px;
    }
    .cluster-panel.collapsed #clusterList .label,
    .cluster-panel.collapsed #clusterList .count {
      display: none;
    }
    .cluster-panel.collapsed .cluster-item {
      justify-content: center;
      padding: 6px;
    }
    .cluster-panel.collapsed .cluster-item .dot {
      width: 16px;
      height: 16px;
    }
    .cluster-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .cluster-panel.collapsed .cluster-header {
      justify-content: center;
    }
    .cluster-panel.collapsed .cluster-header h3 {
      display: none;
    }
    .cluster-panel h3 {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }
    .collapse-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      font-size: 10px;
      border-radius: 4px;
    }
    .collapse-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }
    .cluster-panel.collapsed .collapse-btn {
      transform: rotate(180deg);
    }
    .cluster-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      margin-bottom: 4px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      color: var(--text-secondary);
    }
    .cluster-item:hover {
      background: var(--bg-tertiary);
    }
    .cluster-item.active {
      background: var(--bg-tertiary);
      outline: 2px solid var(--accent);
    }
    .cluster-item .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .cluster-item .label {
      flex: 1;
      line-height: 1.3;
    }
    .cluster-item .count {
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Filter status */
    .filter-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      transition: all 0.2s;
    }
    .filter-status.updating {
      background: #f59e0b33;
      color: #f59e0b;
    }
    .filter-status.done {
      background: #10b98133;
      color: #10b981;
    }

    /* Mode toggle */
    .mode-toggle {
      display: flex;
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 2px;
      gap: 2px;
    }
    .mode-option {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.15s;
    }
    .mode-option:hover {
      color: var(--text-secondary);
    }
    .mode-option.active {
      background: var(--accent);
      color: white;
    }
  </style>
</head>
<body>
  <header>
    <h1>Paper Map</h1>
    <button class="theme-toggle" id="themeToggle" title="Toggle theme">üåô</button>
    <div class="stats" id="stats">Loading...</div>
    <span class="filter-status" id="filterStatus"></span>
    <div class="legend">
      <div class="legend-item">
        <div class="legend-dot" style="background: #58a6ff;"></div>
        <span>Papers</span>
      </div>
      <div class="legend-item">
        <div class="legend-diamond"></div>
        <span>Apps/Services</span>
      </div>
    </div>
    <div class="controls">
      <div class="control-group">
        <label>Min Year:</label>
        <input type="number" id="minYear" value="1990" min="1990" max="2025">
      </div>
      <div class="control-group">
        <label>Min Venue Quality:</label>
        <select id="minVenue">
          <option value="0">All</option>
          <option value="3">3+</option>
          <option value="4">4+</option>
          <option value="5">5 only</option>
        </select>
      </div>
      <div class="control-group">
        <input type="checkbox" id="papersOnly">
        <label for="papersOnly">Papers only</label>
      </div>
      <div class="control-group">
        <label>Tag:</label>
        <select id="tagFilter" style="width: 120px;">
          <option value="">All tags</option>
        </select>
      </div>
      <div class="control-group">
        <label>Search:</label>
        <input type="text" id="searchFilter" placeholder="keyword in notes" style="width: 120px;">
      </div>
      <div class="control-group" style="border-left: 1px solid #30363d; padding-left: 16px;">
        <label>Intersection:</label>
        <select id="intersectCluster1" style="width: 90px;">
          <option value="">C1</option>
        </select>
        <span style="color: #8b949e;">‚Üî</span>
        <select id="intersectCluster2" style="width: 90px;">
          <option value="">C2</option>
        </select>
        <button id="findIntersection" style="background: #8b5cf6;">Find</button>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showCitations" checked>
        <label for="showCitations">Citations</label>
      </div>
      <button id="resetFilter" style="background: #30363d;">Reset</button>
      <div class="mode-toggle" id="modeToggle">
        <span class="mode-option" data-mode="highlight">Highlight</span>
        <span class="mode-option" data-mode="filter">Filter</span>
      </div>
    </div>
  </header>

  <div class="main-content">
    <div class="cluster-panel" id="clusterPanel">
      <div class="cluster-header">
        <h3>Clusters</h3>
        <button class="collapse-btn" id="collapseCluster" title="Toggle panel">‚óÄ</button>
      </div>
      <div id="clusterList"></div>
    </div>
    <div id="plot"></div>
    <div class="detail-panel" id="detailPanel">
      <div class="resize-handle" id="resizeHandle"></div>
      <h2 id="detailTitle">-</h2>
      <div class="meta" id="detailMeta"></div>
      <div class="links" id="detailLinks"></div>
      <div class="abstract" id="detailAbstract"></div>
      <div id="detailNotes"></div>
      <div class="similar-papers" id="similarPapers"></div>
    </div>
  </div>

  <script>
    let allPapers = [];
    let currentFiltered = [];
    let clusterCentroids = {};
    let clusterLabels = {};
    let citationLinks = [];
    let showCitations = true;
    let highlightCluster = null;  // null = Ï†ÑÏ≤¥, Ïà´Ïûê = Ìï¥Îãπ ÌÅ¥Îü¨Ïä§ÌÑ∞ ÌïòÏù¥ÎùºÏù¥Ìä∏
    let filterMode = 'highlight';  // 'filter' = Ïà®ÍπÄ, 'highlight' = ÌùêÎ¶¨Í≤å
    let selectedPaper = null;  // ÏÑ†ÌÉùÎêú ÎÖºÎ¨∏
    let connectedPapers = new Set();  // ÏÑ†ÌÉùÎêú ÎÖºÎ¨∏Í≥º Ïó∞Í≤∞Îêú ÎÖºÎ¨∏Îì§
    const CLUSTER_COLORS = [
      '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7',
      '#dfe6e9', '#a29bfe', '#fd79a8', '#00b894', '#e17055',
      '#74b9ff', '#55efc4', '#b2bec3', '#ffeaa7', '#fab1a0'
    ];

    async function loadData() {
      try {
        const resp = await fetch('papers.json');
        const data = await resp.json();

        // ÏÉà Ìè¨Îß∑ (papers Î∞∞Ïó¥ + centroids) vs Í∏∞Ï°¥ Ìè¨Îß∑ (Î∞∞Ïó¥Îßå)
        if (data.papers) {
          allPapers = data.papers;
          clusterCentroids = data.cluster_centroids || {};
          clusterLabels = data.cluster_labels || {};
          citationLinks = data.citation_links || [];
        } else {
          allPapers = data;
        }

        // Populate tag filter
        const tagFilterEl = document.getElementById('tagFilter');
        const allTags = new Set();
        allPapers.forEach(p => {
          if (p.tags) {
            // tagsÎäî "tag1; tag2; tag3" ÎòêÎäî "tag1, tag2" ÌòïÏãùÏùº Ïàò ÏûàÏùå
            p.tags.split(/[;,]/).forEach(t => {
              const tag = t.trim();
              if (tag) allTags.add(tag);
            });
          }
        });
        [...allTags].sort().forEach(tag => {
          const opt = document.createElement('option');
          opt.value = tag;
          opt.textContent = tag;
          tagFilterEl.appendChild(opt);
        });

        // Populate cluster filter with labels
        const clusters = [...new Set(allPapers.map(p => p.cluster))].sort((a,b) => a-b);
        const intersect1 = document.getElementById('intersectCluster1');
        const intersect2 = document.getElementById('intersectCluster2');
        const clusterListEl = document.getElementById('clusterList');

        clusters.forEach(c => {
          const sample = allPapers.find(p => p.cluster === c);
          const label = clusterLabels[c] || sample?.cluster_label || '';
          const count = allPapers.filter(p => p.cluster === c).length;

          // ÍµêÏ∞®Ï†ê ÏÑ†ÌÉù 1
          const opt1 = document.createElement('option');
          opt1.value = c;
          opt1.textContent = `${c}: ${label.substring(0, 20)}`;
          intersect1.appendChild(opt1);

          // ÍµêÏ∞®Ï†ê ÏÑ†ÌÉù 2
          const opt2 = document.createElement('option');
          opt2.value = c;
          opt2.textContent = `${c}: ${label.substring(0, 20)}`;
          intersect2.appendChild(opt2);

          // ÌÅ¥Îü¨Ïä§ÌÑ∞ Ìå®ÎÑê ÏïÑÏù¥ÌÖú
          const item = document.createElement('div');
          item.className = 'cluster-item';
          item.dataset.cluster = c;
          item.innerHTML = `
            <div class="dot" style="background: ${CLUSTER_COLORS[c % CLUSTER_COLORS.length]}"></div>
            <div class="label">${label || 'Cluster ' + c}</div>
            <div class="count">${count}</div>
          `;
          item.addEventListener('click', () => {
            if (highlightCluster === c) {
              highlightCluster = null;
              item.classList.remove('active');
            } else {
              document.querySelectorAll('.cluster-item').forEach(el => el.classList.remove('active'));
              highlightCluster = c;
              item.classList.add('active');
            }
            render(currentFiltered);
          });
          clusterListEl.appendChild(item);
        });

        currentFiltered = [...allPapers];
        render(currentFiltered);
        updateStats(currentFiltered);
      } catch (e) {
        document.getElementById('stats').textContent = 'Error loading papers.json';
        console.error(e);
      }
    }

    function filterPapers() {
      const minYear = parseInt(document.getElementById('minYear').value) || 0;
      const minVenue = parseFloat(document.getElementById('minVenue').value) || 0;
      const papersOnly = document.getElementById('papersOnly').checked;
      const tagFilter = document.getElementById('tagFilter').value;
      const searchFilter = document.getElementById('searchFilter').value.toLowerCase().trim();

      return allPapers.filter(p => {
        if (p.year && p.year < minYear) return false;
        if (p.venue_quality < minVenue) return false;
        if (papersOnly && !p.is_paper) return false;
        if (tagFilter) {
          const paperTags = (p.tags || '').split(/[;,]/).map(t => t.trim().toLowerCase());
          if (!paperTags.includes(tagFilter.toLowerCase())) return false;
        }
        if (searchFilter) {
          const searchText = `${p.title} ${p.abstract} ${p.notes || ''}`.toLowerCase();
          if (!searchText.includes(searchFilter)) return false;
        }
        return true;
      });
    }

    function updateStats(papers) {
      const paperCount = papers.filter(p => p.is_paper).length;
      const appCount = papers.filter(p => !p.is_paper).length;
      document.getElementById('stats').textContent =
        `${papers.length} items (${paperCount} papers, ${appCount} apps/services)`;
    }

    function render(filteredPapers) {
      // highlight Î™®ÎìúÎ©¥ Ï†ÑÏ≤¥ ÎÖºÎ¨∏ ÌëúÏãú, filter Î™®ÎìúÎ©¥ ÌïÑÌÑ∞Îêú Í≤ÉÎßå
      const papers = filterMode === 'highlight' ? allPapers : filteredPapers;
      const filteredIds = new Set(filteredPapers.map(p => p.id));

      // Separate papers and apps
      const paperItems = papers.filter(p => p.is_paper);
      const appItems = papers.filter(p => !p.is_paper);

      // opacity Í≥ÑÏÇ∞ Ìï®Ïàò
      function getOpacity(p, baseOpacity) {
        // ÏÑ†ÌÉùÎêú ÎÖºÎ¨∏Ïù¥ ÏûàÏúºÎ©¥ - Ï†ÑÏ≤¥ Îßµ Î≥¥Ïù¥Í≤å, ÏÇ¥ÏßùÎßå Í∞ïÏ°∞
        if (selectedPaper !== null) {
          if (p.id === selectedPaper.id) return 1;
          if (connectedPapers.has(p.id)) return 0.9;
          return 0.5;  // ÎÇòÎ®∏ÏßÄÎèÑ Î∞ò Ï†ïÎèÑ Î≥¥Ïù¥Í≤å
        }
        // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÌïòÏù¥ÎùºÏù¥Ìä∏Í∞Ä ÏûàÏúºÎ©¥ Í∑∏Í≤É Ïö∞ÏÑ†
        if (highlightCluster !== null) {
          return p.cluster === highlightCluster ? 1 : 0.15;
        }
        // highlight Î™®ÎìúÏóêÏÑú ÌïÑÌÑ∞ Îß§Ïπ≠ Ïó¨Î∂Ä
        if (filterMode === 'highlight') {
          return filteredIds.has(p.id) ? baseOpacity : 0.15;
        }
        return baseOpacity;
      }

      // ÎßàÏª§ ÌÅ¨Í∏∞ - ÏÑ†ÌÉùÍ≥º Î¨¥Í¥ÄÌïòÍ≤å ÏùºÏ†ï
      function getSize(p) {
        const baseSize = 8 + p.venue_quality * 2;
        const citationBonus = p.citation_count ? Math.log10(p.citation_count + 1) * 3 : 0;
        return baseSize + citationBonus;
      }

      // ÏÑ†ÌÉùÎêú ÎÖºÎ¨∏ ÌÖåÎëêÎ¶¨
      function getLineWidth(p) {
        if (selectedPaper !== null && p.id === selectedPaper.id) return 4;
        if (selectedPaper !== null && connectedPapers.has(p.id)) return 3;
        return 1;
      }

      function getLineColor(p) {
        if (selectedPaper !== null && p.id === selectedPaper.id) return '#ffd700';
        if (selectedPaper !== null && connectedPapers.has(p.id)) return '#ff6b6b';
        return '#0d1117';
      }

      // Îã®Ïñ¥ Îã®ÏúÑ Ï§ÑÎ∞îÍøà Ìï®Ïàò
      function wrapText(text, maxLen = 25) {
        const words = text.split(' ');
        const lines = [];
        let line = '';
        for (const word of words) {
          if ((line + ' ' + word).trim().length <= maxLen) {
            line = (line + ' ' + word).trim();
          } else {
            if (line) lines.push(line);
            line = word;
          }
        }
        if (line) lines.push(line);
        return lines.join('<br>');
      }

      // Papers trace (circles)
      const paperTrace = {
        x: paperItems.map(p => p.x),
        y: paperItems.map(p => p.y),
        text: paperItems.map(p => {
          const wrappedTitle = wrapText(p.title || '', 28);
          return `<b>${wrappedTitle}</b><br><br>` +
            `${p.year || 'N/A'}<br>` +
            `${(p.venue || '').substring(0, 30)}<br>` +
            `Cluster ${p.cluster}`;
        }),
        customdata: paperItems,
        mode: 'markers',
        type: 'scatter',
        name: 'Papers',
        marker: {
          size: paperItems.map(p => getSize(p)),
          color: paperItems.map(p => CLUSTER_COLORS[p.cluster % CLUSTER_COLORS.length]),
          opacity: paperItems.map(p => getOpacity(p, 0.8)),
          line: {
            width: paperItems.map(p => getLineWidth(p)),
            color: paperItems.map(p => getLineColor(p))
          }
        },
        hovertemplate: '%{text}<extra></extra>'
      };

      // Apps trace (diamonds)
      const appTrace = {
        x: appItems.map(p => p.x),
        y: appItems.map(p => p.y),
        text: appItems.map(p => {
          const wrappedTitle = wrapText(p.title || '', 28);
          return `<b>${wrappedTitle}</b><br><br>` +
            `App/Service<br>` +
            `Cluster ${p.cluster}`;
        }),
        customdata: appItems,
        mode: 'markers',
        type: 'scatter',
        name: 'Apps/Services',
        marker: {
          size: 14,
          symbol: 'diamond',
          color: appItems.map(p => CLUSTER_COLORS[p.cluster % CLUSTER_COLORS.length]),
          opacity: appItems.map(p => getOpacity(p, 0.9)),
          line: { width: 2, color: '#bc8cff' }
        },
        hovertemplate: '%{text}<extra></extra>'
      };

      const isLight = document.documentElement.dataset.theme === 'light';
      const colors = isLight ? {
        bg: '#ffffff', grid: '#eaeef2', zero: '#d0d7de', text: '#656d76'
      } : {
        bg: '#0d1117', grid: '#21262d', zero: '#30363d', text: '#8b949e'
      };

      const layout = {
        margin: { l: 40, r: 20, t: 20, b: 40 },
        paper_bgcolor: colors.bg,
        plot_bgcolor: colors.bg,
        xaxis: {
          title: '',
          showgrid: true,
          gridcolor: colors.grid,
          zerolinecolor: colors.zero,
          tickfont: { color: colors.text }
        },
        yaxis: {
          title: '',
          showgrid: true,
          gridcolor: colors.grid,
          zerolinecolor: colors.zero,
          tickfont: { color: colors.text }
        },
        showlegend: false,
        hovermode: 'closest'
      };

      const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d']
      };

      // Ïù∏Ïö© Í¥ÄÍ≥Ñ ÏÑ† Ï∂îÍ∞Ä
      const traces = [paperTrace, appTrace];

      if (showCitations && citationLinks.length > 0) {
        // ÌòÑÏû¨ ÌïÑÌÑ∞Îêú ÎÖºÎ¨∏Îì§Ïùò ID Îßµ
        const filteredIds = new Set(papers.map(p => p.id));
        const idToPos = {};
        papers.forEach(p => { idToPos[p.id] = { x: p.x, y: p.y }; });

        // ÌïÑÌÑ∞Îêú ÎÖºÎ¨∏Îì§ ÏÇ¨Ïù¥Ïùò Ïù∏Ïö© Í¥ÄÍ≥ÑÎßå ÌëúÏãú
        const relevantLinks = citationLinks.filter(
          link => filteredIds.has(link.source) && filteredIds.has(link.target)
        );

        // Í∞Å ÎßÅÌÅ¨Î•º ÏÑ†ÏúºÎ°ú Í∑∏Î¶¨Í∏∞
        relevantLinks.forEach(link => {
          const source = idToPos[link.source];
          const target = idToPos[link.target];
          if (source && target) {
            traces.push({
              x: [source.x, target.x],
              y: [source.y, target.y],
              mode: 'lines',
              type: 'scatter',
              line: { color: 'rgba(255, 165, 0, 0.3)', width: 1 },
              hoverinfo: 'none',
              showlegend: false
            });
          }
        });
      }

      const plotDiv = document.getElementById('plot');

      Plotly.newPlot(plotDiv, traces, layout, config).then(function() {
        plotDiv.on('plotly_click', function(data) {
          if (data.points && data.points[0] && data.points[0].customdata) {
            showDetail(data.points[0].customdata);
          }
        });

        // Îπà Í≥≥ ÎçîÎ∏îÌÅ¥Î¶≠ÌïòÎ©¥ ÏÑ†ÌÉù Ìï¥Ï†ú
        plotDiv.on('plotly_doubleclick', function() {
          clearSelection();
        });
      });
    }

    function clearSelection() {
      selectedPaper = null;
      connectedPapers = new Set();
      document.getElementById('detailPanel').classList.remove('active');
      setTimeout(() => Plotly.Plots.resize('plot'), 10);
      render(currentFiltered);
    }

    function showDetail(item) {
      const panel = document.getElementById('detailPanel');
      panel.classList.add('active');
      // Ï†ÄÏû•Îêú ÎÑàÎπÑ Ï†ÅÏö©
      const savedWidth = localStorage.getItem('detailPanelWidth');
      if (savedWidth) {
        panel.style.width = savedWidth;
      }
      setTimeout(() => Plotly.Plots.resize('plot'), 10);

      // ÏÑ†ÌÉùÎêú ÎÖºÎ¨∏Í≥º Ïó∞Í≤∞Îêú ÎÖºÎ¨∏Îì§ ÏÑ§Ï†ï
      selectedPaper = item;
      connectedPapers = new Set();

      // citation linksÏóêÏÑú Ïó∞Í≤∞Îêú ÎÖºÎ¨∏ Ï∞æÍ∏∞
      citationLinks.forEach(link => {
        if (link.source === item.id) connectedPapers.add(link.target);
        if (link.target === item.id) connectedPapers.add(link.source);
      });

      // Îßµ Îã§Ïãú Î†åÎçîÎßÅ
      render(currentFiltered);

      document.getElementById('detailTitle').textContent = item.title || 'Untitled';

      const typeClass = item.is_paper ? 'paper' : 'app';
      const typeLabel = item.is_paper ? 'Paper' : 'App/Service';

      const citationBadge = item.citation_count !== null && item.citation_count !== undefined
        ? `<span class="badge" style="background: #ffd70033; color: #ffd700;">Cited: ${item.citation_count}</span>`
        : '';

      const connectedBadge = connectedPapers.size > 0
        ? `<span class="badge" style="background: #ff6b6b33; color: #ff6b6b;">Connected: ${connectedPapers.size}</span>`
        : '';

      document.getElementById('detailMeta').innerHTML = `
        <span class="badge ${typeClass}">${typeLabel}</span>
        <span class="badge cluster">Cluster ${item.cluster}: ${item.cluster_label || ''}</span>
        ${citationBadge}
        ${connectedBadge}
        <br><br>
        <span><strong>Year:</strong> ${item.year || 'N/A'}</span>
        <span><strong>Venue:</strong> ${item.venue || 'N/A'}</span>
        <span><strong>Quality:</strong> ${item.venue_quality}/5</span>
        ${item.citation_count !== null ? `<span><strong>Citations:</strong> ${item.citation_count}</span>` : ''}
        ${item.authors ? `<br><span><strong>Authors:</strong> ${item.authors.substring(0, 100)}${item.authors.length > 100 ? '...' : ''}</span>` : ''}
        ${item.tags ? `<br><span><strong>Tags:</strong> ${item.tags}</span>` : ''}
      `;

      let linksHtml = '';
      if (item.url) {
        linksHtml += `<a href="${item.url}" target="_blank">Open URL</a>`;
      }
      if (item.doi) {
        linksHtml += `<a href="https://doi.org/${item.doi}" target="_blank">DOI</a>`;
      }
      document.getElementById('detailLinks').innerHTML = linksHtml;

      document.getElementById('detailAbstract').textContent =
        item.abstract || 'No abstract available.';

      // ÎÖ∏Ìä∏ ÌëúÏãú
      const notesHtml = item.notes
        ? `<div class="notes"><h3>Notes</h3><div class="notes-content">${item.notes.replace(/\n/g, '<br>')}</div></div>`
        : '';
      document.getElementById('detailNotes').innerHTML = notesHtml;

      // Find similar papers (closest by x,y coordinates)
      const similar = findSimilarPapers(item, allPapers, 5);
      let similarHtml = '<h3>Similar Papers</h3><ul>';
      similar.forEach(p => {
        const title = p.title.length > 50 ? p.title.substring(0, 50) + '...' : p.title;
        similarHtml += `<li data-id="${p.id}">${title} <span class="year">(${p.year || 'N/A'})</span></li>`;
      });
      similarHtml += '</ul>';
      document.getElementById('similarPapers').innerHTML = similarHtml;

      // Click handler for similar papers
      document.querySelectorAll('#similarPapers li').forEach(li => {
        li.addEventListener('click', () => {
          const paperId = parseInt(li.dataset.id);
          const paper = allPapers.find(p => p.id === paperId);
          if (paper) showDetail(paper);
        });
      });
    }

    function findSimilarPapers(target, papers, n = 5) {
      return papers
        .filter(p => p.id !== target.id)
        .map(p => ({
          ...p,
          distance: Math.sqrt(Math.pow(p.x - target.x, 2) + Math.pow(p.y - target.y, 2))
        }))
        .sort((a, b) => a.distance - b.distance)
        .slice(0, n);
    }

    function findIntersectionPapers(cluster1, cluster2, threshold = 0.3) {
      // Îëê ÌÅ¥Îü¨Ïä§ÌÑ∞Ïùò Ï§ëÏã¨Ï†ê Í∞ÄÏ†∏Ïò§Í∏∞
      const c1 = clusterCentroids[cluster1];
      const c2 = clusterCentroids[cluster2];

      if (!c1 || !c2) {
        // centroidsÍ∞Ä ÏóÜÏúºÎ©¥ papersÏóêÏÑú ÏßÅÏ†ë Í≥ÑÏÇ∞
        const c1Papers = allPapers.filter(p => p.cluster === cluster1);
        const c2Papers = allPapers.filter(p => p.cluster === cluster2);

        const centroid1 = {
          x: c1Papers.reduce((s, p) => s + p.x, 0) / c1Papers.length,
          y: c1Papers.reduce((s, p) => s + p.y, 0) / c1Papers.length
        };
        const centroid2 = {
          x: c2Papers.reduce((s, p) => s + p.x, 0) / c2Papers.length,
          y: c2Papers.reduce((s, p) => s + p.y, 0) / c2Papers.length
        };

        return findPapersNearBothCentroids(centroid1, centroid2, threshold);
      }

      return findPapersNearBothCentroids(c1, c2, threshold);
    }

    function findPapersNearBothCentroids(c1, c2, threshold) {
      // Îëê Ï§ëÏã¨Ï†ê ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨
      const distBetween = Math.sqrt(Math.pow(c2.x - c1.x, 2) + Math.pow(c2.y - c1.y, 2));

      // Í∞Å ÎÖºÎ¨∏ÏóêÏÑú Îëê Ï§ëÏã¨Ï†êÍπåÏßÄÏùò Í±∞Î¶¨ Í≥ÑÏÇ∞
      return allPapers
        .map(p => {
          const d1 = Math.sqrt(Math.pow(p.x - c1.x, 2) + Math.pow(p.y - c1.y, 2));
          const d2 = Math.sqrt(Math.pow(p.x - c2.x, 2) + Math.pow(p.y - c2.y, 2));
          // Îëê Í±∞Î¶¨Ïùò Ìï©Ïù¥ Îëê Ï§ëÏã¨Ï†ê Í±∞Î¶¨Ïùò (1 + threshold) Î∞∞ Ïù¥ÎÇ¥Î©¥ "ÍµêÏ∞®Ï†ê"
          // Ï¶â, Îëê ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÇ¨Ïù¥ Í≤ΩÎ°úÏóê Í∞ÄÍπåÏö¥ ÎÖºÎ¨∏Îì§
          const ratio = (d1 + d2) / distBetween;
          return { ...p, intersectionScore: ratio, d1, d2 };
        })
        .filter(p => p.intersectionScore <= 1 + threshold)
        .sort((a, b) => a.intersectionScore - b.intersectionScore);
    }

    // ÌïÑÌÑ∞ ÏÉÅÌÉú ÌëúÏãú
    const filterStatus = document.getElementById('filterStatus');
    let statusTimer = null;

    function showFilterStatus(status) {
      filterStatus.className = 'filter-status ' + status;
      filterStatus.textContent = status === 'updating' ? '‚è≥' : '‚úì';

      if (status === 'done') {
        clearTimeout(statusTimer);
        statusTimer = setTimeout(() => {
          filterStatus.className = 'filter-status';
          filterStatus.textContent = '';
        }, 800);
      }
    }

    // ÌïÑÌÑ∞ Ï¶âÏãú Ï†ÅÏö© Ìï®Ïàò
    function applyFilters() {
      currentFiltered = filterPapers();
      render(currentFiltered);
      updateStats(currentFiltered);
      showFilterStatus('done');
    }

    // Debounce Ìï®Ïàò
    function debounce(fn, delay) {
      let timer = null;
      return function(...args) {
        showFilterStatus('updating');
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    const debouncedApplyFilters = debounce(applyFilters, 200);

    // Event handlers - ÌïÑÌÑ∞ Î≥ÄÍ≤Ω Ïãú Ï¶âÏãú Ï†ÅÏö©
    document.getElementById('minYear').addEventListener('change', applyFilters);
    document.getElementById('minVenue').addEventListener('change', applyFilters);
    document.getElementById('papersOnly').addEventListener('change', applyFilters);
    document.getElementById('tagFilter').addEventListener('change', applyFilters);
    document.getElementById('searchFilter').addEventListener('input', debouncedApplyFilters);

    document.getElementById('resetFilter').addEventListener('click', () => {
      document.getElementById('minYear').value = '1990';
      document.getElementById('minVenue').value = '0';
      document.getElementById('papersOnly').checked = false;
      document.getElementById('tagFilter').value = '';
      document.getElementById('searchFilter').value = '';
      document.getElementById('intersectCluster1').value = '';
      document.getElementById('intersectCluster2').value = '';
      document.getElementById('showCitations').checked = true;
      showCitations = true;
      highlightCluster = null;
      filterMode = 'highlight';
      document.querySelectorAll('.mode-option').forEach(o => o.classList.remove('active'));
      document.querySelector('.mode-option[data-mode="highlight"]').classList.add('active');
      document.querySelectorAll('.cluster-item').forEach(el => el.classList.remove('active'));
      selectedPaper = null;
      connectedPapers = new Set();
      document.getElementById('detailPanel').classList.remove('active');
      currentFiltered = [...allPapers];
      render(currentFiltered);
      updateStats(currentFiltered);
    });

    document.getElementById('showCitations').addEventListener('change', (e) => {
      showCitations = e.target.checked;
      render(currentFiltered);
    });

    // Mode toggle
    document.querySelectorAll('.mode-option').forEach(opt => {
      opt.addEventListener('click', () => {
        filterMode = opt.dataset.mode;
        document.querySelectorAll('.mode-option').forEach(o => o.classList.remove('active'));
        opt.classList.add('active');
        render(currentFiltered);
      });
    });
    // Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï
    document.querySelector(`.mode-option[data-mode="${filterMode}"]`).classList.add('active');

    document.getElementById('findIntersection').addEventListener('click', () => {
      const c1 = document.getElementById('intersectCluster1').value;
      const c2 = document.getElementById('intersectCluster2').value;

      if (!c1 || !c2) {
        alert('Îëê ÌÅ¥Îü¨Ïä§ÌÑ∞Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî');
        return;
      }
      if (c1 === c2) {
        alert('ÏÑúÎ°ú Îã§Î•∏ ÌÅ¥Îü¨Ïä§ÌÑ∞Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî');
        return;
      }

      const intersectionPapers = findIntersectionPapers(parseInt(c1), parseInt(c2));
      if (intersectionPapers.length === 0) {
        alert('ÍµêÏ∞®Ï†ê ÎÖºÎ¨∏Ïù¥ ÏóÜÏäµÎãàÎã§');
        return;
      }

      currentFiltered = intersectionPapers;
      render(currentFiltered);
      updateStats(currentFiltered);

      // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÎùºÎ≤® ÌëúÏãú
      const label1 = clusterLabels[c1] || '';
      const label2 = clusterLabels[c2] || '';
      document.getElementById('stats').textContent +=
        ` | Intersection: C${c1} ‚Üî C${c2}`;
    });

    // Theme toggle
    document.getElementById('themeToggle').addEventListener('click', () => {
      const html = document.documentElement;
      const isLight = html.dataset.theme === 'light';
      html.dataset.theme = isLight ? '' : 'light';
      document.getElementById('themeToggle').textContent = isLight ? 'üåô' : '‚òÄÔ∏è';
      localStorage.setItem('theme', html.dataset.theme);
      render(currentFiltered);
    });

    // Load saved theme
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {
      document.documentElement.dataset.theme = 'light';
      document.getElementById('themeToggle').textContent = '‚òÄÔ∏è';
    }

    // ÌÅ¥Îü¨Ïä§ÌÑ∞ Ìå®ÎÑê Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞
    const clusterPanel = document.getElementById('clusterPanel');
    if (localStorage.getItem('clusterCollapsed') === 'true') {
      clusterPanel.classList.add('collapsed');
    }

    document.getElementById('collapseCluster').addEventListener('click', () => {
      clusterPanel.classList.toggle('collapsed');
      localStorage.setItem('clusterCollapsed', clusterPanel.classList.contains('collapsed'));
      setTimeout(() => Plotly.Plots.resize('plot'), 250);
    });

    // ÏÇ¨Ïù¥ÎìúÌå®ÎÑê Î¶¨ÏÇ¨Ïù¥Ï¶à
    const resizeHandle = document.getElementById('resizeHandle');
    const detailPanel = document.getElementById('detailPanel');
    let isResizing = false;

    resizeHandle.addEventListener('mousedown', (e) => {
      isResizing = true;
      resizeHandle.classList.add('dragging');
      document.body.style.cursor = 'ew-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      const newWidth = window.innerWidth - e.clientX;
      if (newWidth >= 250 && newWidth <= 600) {
        detailPanel.style.width = newWidth + 'px';
        Plotly.Plots.resize('plot');
      }
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        resizeHandle.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        // ÎÑàÎπÑ Ï†ÄÏû•
        localStorage.setItem('detailPanelWidth', detailPanel.style.width);
      }
    });

    // Load data
    loadData();
  </script>
</body>
</html>
